<html>
<head>
    <title>Line Chart</title>
    <script src="../js/Chart/Chart.bundle.js"></script>
    <style>
        canvas {
            -moz-user-select: none;
            -webkit-user-select: none;
            -ms-user-select: none;
        }
    </style>
    <link rel="stylesheet" type="text/css" href="chrome-extension://peeecebkcdlibcfllbpmmkhggflcppem/Content%20Script/Content.css">
    <style type="text/css">/* Chart.js */
    @keyframes chartjs-render-animation {
        from {
            opacity: .99
        }
        to {
            opacity: 1
        }
    }

    .chartjs-render-monitor {
        animation: chartjs-render-animation 1ms
    }

    .chartjs-size-monitor, .chartjs-size-monitor-expand, .chartjs-size-monitor-shrink {
        position: absolute;
        direction: ltr;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        overflow: hidden;
        pointer-events: none;
        visibility: hidden;
        z-index: -1
    }

    .chartjs-size-monitor-expand > div {
        position: absolute;
        width: 1000000px;
        height: 1000000px;
        left: 0;
        top: 0
    }

    .chartjs-size-monitor-shrink > div {
        position: absolute;
        width: 200%;
        height: 200%;
        left: 0;
        top: 0
    }</style>
</head>

<body>
<div style="width:75%;">
    <div class="chartjs-size-monitor">
        <div class="chartjs-size-monitor-expand">
            <div class=""></div>
        </div>
        <div class="chartjs-size-monitor-shrink">
            <div class=""></div>
        </div>
    </div>
    <canvas id="canvas" style="display: block; width: 1422px; height: 711px;" width="1422" height="711" class="chartjs-render-monitor"></canvas>
</div>
<script>
    var config = {
        type: 'CompetVetSuiviSemesters',
        labels: ['Comp√©tences', 'Connaissance'],
        data: {
            labels: ["S1","S2","S3","S4"],
            datasets: [{data: [0.1, 0.5],}, {data: [0.2, 0.8],}],
        },
        options: {
            xAxes: [{
                type: 'category',
                categoryPercentage: 0.8,
                barPercentage: 0.9,
                offset: true,
                gridLines: {
                    offsetGridLines: true
                }
            }],
            yAxes: [{
                type: 'linear',
                stacked: true,
            }]
        }
    };

    window.onload = function () {
        /*Chart.plugins.register({
            afterDatasetsUpdate: function (chart) {
                Chart.helpers.each(chart.getDatasetMeta(0).data, function (rectangle) {
                    rectangle._view.width = rectangle._model.height *= 0.75;
                });
            },
        });*/

        function computeFitCategoryTraits(index, ruler, options) {
            var thickness = options.barThickness;
            var count = ruler.stackCount;
            var curr = ruler.pixels[index];
            var size, ratio;

            if (Chart.helpers.isNullOrUndef(thickness)) {
                size = ruler.min * options.categoryPercentage;
                ratio = options.barPercentage;
            } else {
                // When bar thickness is enforced, category and bar percentages are ignored.
                // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
                // and deprecate barPercentage since this value is ignored when thickness is absolute.
                size = thickness * count;
                ratio = 1;
            }

            return {
                chunk: size / count,
                ratio: ratio,
                start: curr - (size / 2)
            };
        }

        Chart.defaults._set('global', {
            hover: {
                mode: 'label'
            },

            scales: {
                xAxes: [{
                    type: 'category',
                    categoryPercentage: 0.8,
                    barPercentage: 0.9,
                    offset: true,
                    gridLines: {
                        offsetGridLines: true
                    }
                }],

                yAxes: [{
                    type: ''
                }]
            }
        });
        Chart.controllers.CompetVetSuiviSemesters = Chart.DatasetController.extend({
            dataElementType: Chart.elements.Rectangle,

            initialize: function() {
                var me = this;
                var meta;

                Chart.DatasetController.prototype.initialize.apply(me, arguments);

                meta = me.getMeta();
                meta.stack = me.getDataset().stack;
                meta.bar = true;
            },

            update: function(reset) {
                var me = this;
                var rects = me.getMeta().data;
                var i, ilen;

                me._ruler = me.getRuler();

                for (i = 0, ilen = rects.length; i < ilen; ++i) {
                    me.updateElement(rects[i], i, reset);
                }
            },

            updateElement: function(rectangle, index, reset) {
                var me = this;
                var meta = me.getMeta();
                var dataset = me.getDataset();
                var options = me._resolveElementOptions(rectangle, index);

                rectangle._xScale = me.getScaleForId(meta.xAxisID);
                rectangle._yScale = me.getScaleForId(meta.yAxisID);
                rectangle._datasetIndex = me.index;
                rectangle._index = index;
                rectangle._model = {
                    backgroundColor: options.backgroundColor,
                    borderColor: options.borderColor,
                    borderSkipped: options.borderSkipped,
                    borderWidth: options.borderWidth,
                    datasetLabel: dataset.label,
                    label: me.chart.data.labels[index]
                };

                me._updateElementGeometry(rectangle, index, reset);

                rectangle.pivot();
            },

            /**
             * @private
             */
            _updateElementGeometry: function(rectangle, index, reset) {
                var me = this;
                var model = rectangle._model;
                var vscale = me._getValueScale();
                var base = vscale.getBasePixel();
                var horizontal = vscale.isHorizontal();
                var ruler = me._ruler || me.getRuler();
                var vpixels = me.calculateBarValuePixels(me.index, index);
                var ipixels = me.calculateBarIndexPixels(me.index, index, ruler);

                model.horizontal = horizontal;
                model.base = reset ? base : vpixels.base;
                model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
                model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
                model.height = horizontal ? ipixels.size : undefined;
                model.width = horizontal ? undefined : ipixels.size;
            },

            /**
             * Returns the stacks based on groups and bar visibility.
             * @param {number} [last] - The dataset index
             * @returns {string[]} The list of stack IDs
             * @private
             */
            _getStacks: function(last) {
                var me = this;
                var chart = me.chart;
                var scale = me._getIndexScale();
                var stacked = scale.options.stacked;
                var ilen = last === undefined ? chart.data.datasets.length : last + 1;
                var stacks = [];
                var i, meta;

                for (i = 0; i < ilen; ++i) {
                    meta = chart.getDatasetMeta(i);
                    if (meta.bar && chart.isDatasetVisible(i) &&
                        (stacked === false ||
                            (stacked === true && stacks.indexOf(meta.stack) === -1) ||
                            (stacked === undefined && (meta.stack === undefined || stacks.indexOf(meta.stack) === -1)))) {
                        stacks.push(meta.stack);
                    }
                }

                return stacks;
            },

            /**
             * Returns the effective number of stacks based on groups and bar visibility.
             * @private
             */
            getStackCount: function() {
                return this._getStacks().length;
            },

            /**
             * Returns the stack index for the given dataset based on groups and bar visibility.
             * @param {number} [datasetIndex] - The dataset index
             * @param {string} [name] - The stack name to find
             * @returns {number} The stack index
             * @private
             */
            getStackIndex: function(datasetIndex, name) {
                var stacks = this._getStacks(datasetIndex);
                var index = (name !== undefined)
                    ? stacks.indexOf(name)
                    : -1; // indexOf returns -1 if element is not present

                return (index === -1)
                    ? stacks.length - 1
                    : index;
            },

            /**
             * @private
             */
            getRuler: function() {
                var me = this;
                var scale = me._getIndexScale();
                var stackCount = me.getStackCount();
                var datasetIndex = me.index;
                var isHorizontal = scale.isHorizontal();
                var start = isHorizontal ? scale.left : scale.top;
                var end = start + (isHorizontal ? scale.width : scale.height);
                var pixels = [];
                var i, ilen, min;

                for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
                    pixels.push(scale.getPixelForValue(null, i, datasetIndex));
                }

                min =  -1;

                return {
                    min: min,
                    pixels: pixels,
                    start: start,
                    end: end,
                    stackCount: stackCount,
                    scale: scale
                };
            },

            /**
             * Note: pixel values are not clamped to the scale area.
             * @private
             */
            calculateBarValuePixels: function(datasetIndex, index) {
                var me = this;
                var chart = me.chart;
                var meta = me.getMeta();
                var scale = me._getValueScale();
                var isHorizontal = scale.isHorizontal();
                var datasets = chart.data.datasets;
                var value = +scale.getRightValue(datasets[datasetIndex].data[index]);
                var minBarLength = scale.options.minBarLength;
                var stacked = scale.options.stacked;
                var stack = meta.stack;
                var start = 0;
                var i, imeta, ivalue, base, head, size;

                if (stacked || (stacked === undefined && stack !== undefined)) {
                    for (i = 0; i < datasetIndex; ++i) {
                        imeta = chart.getDatasetMeta(i);

                        if (imeta.bar &&
                            imeta.stack === stack &&
                            imeta.controller._getValueScaleId() === scale.id &&
                            chart.isDatasetVisible(i)) {

                            ivalue = +scale.getRightValue(datasets[i].data[index]);
                            if ((value < 0 && ivalue < 0) || (value >= 0 && ivalue > 0)) {
                                start += ivalue;
                            }
                        }
                    }
                }

                base = scale.getPixelForValue(start);
                head = scale.getPixelForValue(start + value);
                size = head - base;

                if (minBarLength !== undefined && Math.abs(size) < minBarLength) {
                    size = minBarLength;
                    if (value >= 0 && !isHorizontal || value < 0 && isHorizontal) {
                        head = base - minBarLength;
                    } else {
                        head = base + minBarLength;
                    }
                }

                return {
                    size: size,
                    base: base,
                    head: head,
                    center: head + size / 2
                };
            },

            /**
             * @private
             */
            calculateBarIndexPixels: function(datasetIndex, index, ruler) {
                var me = this;
                var options = ruler.scale.options;
                var range = options.barThickness === 'flex'
                    ? computeFlexCategoryTraits(index, ruler, options)
                    : computeFitCategoryTraits(index, ruler, options);

                var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
                var center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
                var size = Math.min(
                    Chart.helpers.valueOrDefault(options.maxBarThickness, Infinity),
                    range.chunk * range.ratio);

                return {
                    base: center - size / 2,
                    head: center + size / 2,
                    center: center,
                    size: size
                };
            },

            draw: function() {
                var me = this;
                var chart = me.chart;
                var scale = me._getValueScale();
                var rects = me.getMeta().data;
                var dataset = me.getDataset();
                var ilen = rects.length;
                var i = 0;

                Chart.helpers.canvas.clipArea(chart.ctx, chart.chartArea);

                for (; i < ilen; ++i) {
                    if (!isNaN(scale.getRightValue(dataset.data[i]))) {
                        rects[i].draw();
                    }
                }

                Chart.helpers.canvas.unclipArea(chart.ctx);
            },

            /**
             * @private
             */
            _resolveElementOptions: function(rectangle, index) {
                var me = this;
                var chart = me.chart;
                var datasets = chart.data.datasets;
                var dataset = datasets[me.index];
                var custom = rectangle.custom || {};
                var options = chart.options.elements.rectangle;
                var values = {};
                var i, ilen, key;

                // Scriptable options
                var context = {
                    chart: chart,
                    dataIndex: index,
                    dataset: dataset,
                    datasetIndex: me.index
                };

                var keys = [
                    'backgroundColor',
                    'borderColor',
                    'borderSkipped',
                    'borderWidth'
                ];

                for (i = 0, ilen = keys.length; i < ilen; ++i) {
                    key = keys[i];
                    values[key] = Chart.helpers.options.resolve([
                        custom[key],
                        dataset[key],
                        options[key]
                    ], context, index);
                }

                return values;
            }
        });
        var ctx = document.getElementById('canvas').getContext('2d');
        window.myLine = new Chart(ctx, config);
    };
</script>


</body>
</html>